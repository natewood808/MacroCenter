How the workflow of MVC works in my head:

	1) Send request for a URL
	2) MVC maps request to specific route
	3) Controller instance created to handle request
	4) Appropriate controller action method is called
	5) If necessary, pass model/viewmodel data to the view
	6) Render the view to the user

32. We use LibMan to manage client-side libraries. Client-side libraries contains content sent to the client such as JavaScript files, CSS stylesheets, or images. We specify these libraries in the generated libman.json file. We generate this file by selecting the Manage Client-Side Libraries... from the Project menu.

33. Filtering the Product List by Category:
We added a property, CurrentCategory, to the ProductsListViewModel class. We set this new property in the List action method on the ProductController class. The List action method now takes in a "string category" parameter. We also added a LINQ Where enhancement to the ProductsListViewModel.Products property in the List action method in the ProductController.cs file to filter the Products from the repostiory to only ones that match the category specified in the request.

34. Refining the URL Scheme:
We added new routes to the Startup.cs file to make more composable URLs (e.g. /?category=Soccer to /Soccer).
The ASP.NET Core routing system is used by MVC to handle incoming requests/URLs, but it also generates outgoing URLs that conform to the URL scheme, these can be embedded into web pages. We use these outgoing URLs to make links to different pages to preserve the category filter, if any exist.
We added to the PageLinkTagHelper.cs file to generate links on the page that retain the category filter.

35. Building a Category Navigation Menu:
View components are C# classes that provide a small amount of reusable logic with the ability to select and display Razor partial views.
Another more specific definition would be, they are classes that provide application logic to suppport partial views or to inject small fragments of HTML or JSON data into a parent view.
Partial views are only used to prevent duplicated markup across multiple views and only contain HTML and Razor directives, and the data they operate on is received from the parent view. Two problems arise that view components can solve:
	1) Accessing the data we need directly from the partial view breaks the MVC pattern and results in data retrieval and processing logic being placed in a view file.
	2) We could extend the view models to include the data we require, but this means we have to change every action method which makes it hard to isolate the functionality of action methods.
View components solve these problems by providing partial views with the data they need, independently from the parent view and the action method that renders it.

ViewBag is a dynamic object which you can define new properties by merely assigning values to them, making those values available in whatever view is subsequently rendered.

37. Building the Shopping Cart:
We first start by creating a Cart model class in the Models folder. Which holds information about the items in our cart and methods to manipulate the items in the cart.
After that we create the "Add to Cart" button. To support this we create a UrlExtensions class that has an extension method called PathAndQuery(this HttpRequest request). This method generates a URL that the browser will be returned to after the cart has been updated. We add the namespace of this class to the _ViewImports file so we can use this extension method in the partial view, ProductSummary.cshtml.
Next we modified the partial view, ProductSummary.cshtml, mainly to include a form element that has two inputs and a button that adds to cart. The two inputs are used to: 1) specify the ProductID from the view model and 2) specify the URL the browser should be returned to when the cart is updated.

38. Enabling Sessions
We added two packages to the csproj file that are used to implement sessions in our app. The packages are called Microsoft.AspNetCore.Mvc.NewtonsoftJson and Microsoft.Extensions.Caching.Memory. We also configured the Startup class with three methods in ConfigureServices(): .AddNewtonsoftJson(), .AddMemoryCache(), .AddSession. We also added one method to the Configure() method: app.UseSession();

39. Implementing the Cart Controller
We created a CartController.cs class to handle requests for AddToCart and RemoveFromCart actions. These actions redirect the user to a specified returnUrl.

We use ASP.NET session state feature to store and retrieve Cart objects, which is the purpose of GetCart and SaveCart methods.

The middleware we registered in the Startup class in task 38 uses cookies or URL rewriting to associate multiple requests from a user together to form a single browsing session. A related feature is session state, which associates data with a session.

Model Binding - in the CartController.cs class the action methods AddToCart(int productId, stringreturnUrl) and RemoveFromCart(int productId, string returnUrl) have parameter names that match the input elemnts in the HTML form on the ProductSummary.cshtml partial view. This allows MVC to associate incoming form POST variables with those parameters, eliminating the need to process the form.

$Defining Session State Extension Methods
ASP.NET Core's session state feature only stores int, string, and byte[] values so we have to serialize the Cart objectss into JSON. We do this by defining extension methods to the ISession interface in a new class we create in the Infrastructure folder called SessionExtensions.cs.