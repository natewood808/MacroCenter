How the workflow of MVC works in my head:

	1) Send request for a URL
	2) MVC maps request to specific route
	3) Controller instance created to handle request
	4) Appropriate controller action method is called
	5) If necessary, pass model/viewmodel data to the view
	6) Render the view to the user

Task 32 Installing the Bootstrap Package
Client-side packages is a package sent to the client that contain JS files, CSS files, and images.

We handle managing these client-side libraries(packages) using LibMan.

Right clicking on our project and select Manage Client-Side Libraries... generates a libman.json file which we can add libraries such as jQuery and Bootstrap to. Once this file is saved, VS wil download the appropriate files.

asp-href-inlcude


32. We use LibMan to manage client-side libraries. Client-side libraries contains content sent to the client such as JavaScript files, CSS stylesheets, or images. We specify these libraries in the generated libman.json file. We generate this file by selecting the Manage Client-Side Libraries... from the Project menu.

33. Filtering the Product List by Category:
We added a property, CurrentCategory, to the ProductsListViewModel class. We set this new property in the List action method on the ProductController class. The List action method now takes in a "string category" parameter. We also added a LINQ Where enhancement to the ProductsListViewModel.Products property in the List action method in the ProductController.cs file to filter the Products from the repostiory to only ones that match the category specified in the request.

34. Refining the URL Scheme:
We added new routes to the Startup.cs file to make more composable URLs (e.g. /?category=Soccer to /Soccer).
The ASP.NET Core routing system is used by MVC to handle incoming requests/URLs, but it also generates outgoing URLs that conform to the URL scheme, these can be embedded into web pages. We use these outgoing URLs to make links to different pages to preserve the category filter, if any exist.
We added to the PageLinkTagHelper.cs file to generate links on the page that retain the category filter.

35. Building a Category Navigation Menu:
View components are C# classes that provide a small amount of reusable logic with the ability to select and display Razor partial views.
Another more specific definition would be, they are classes that provide application logic to suppport partial views or to inject small fragments of HTML or JSON data into a parent view.
Partial views are only used to prevent duplicated markup across multiple views and only contain HTML and Razor directives, and the data they operate on is received from the parent view. Two problems arise that view components can solve:
	1) Accessing the data we need directly from the partial view breaks the MVC pattern and results in data retrieval and processing logic being placed in a view file.
	2) We could extend the view models to include the data we require, but this means we have to change every action method which makes it hard to isolate the functionality of action methods.
View components solve these problems by providing partial views with the data they need, independently from the parent view and the action method that renders it.

ViewBag is a dynamic object which you can define new properties by merely assigning values to them, making those values available in whatever view is subsequently rendered.

37. Building the Shopping Cart:
We first start by creating a Cart model class in the Models folder. Which holds information about the items in our cart and methods to manipulate the items in the cart.
After that we create the "Add to Cart" button. To support this we create a UrlExtensions class that has an extension method called PathAndQuery(this HttpRequest request). This method generates a URL that the browser will be returned to after the cart has been updated. We add the namespace of this class to the _ViewImports file so we can use this extension method in the partial view, ProductSummary.cshtml.
Next we modified the partial view, ProductSummary.cshtml, mainly to include a form element that has two inputs and a button that adds to cart. The two inputs are used to: 1) specify the ProductID from the view model and 2) specify the URL the browser should be returned to when the cart is updated.

38. Enabling Sessions
We added two packages to the csproj file that are used to implement sessions in our app. The packages are called Microsoft.AspNetCore.Mvc.NewtonsoftJson and Microsoft.Extensions.Caching.Memory. We also configured the Startup class with three methods in ConfigureServices(): .AddNewtonsoftJson(), .AddMemoryCache(), .AddSession. We also added one method to the Configure() method: app.UseSession();

39. Implementing the Cart Controller
We created a CartController.cs class to handle requests for AddToCart and RemoveFromCart actions. These actions redirect the user to a specified returnUrl.

We use ASP.NET session state feature to store and retrieve Cart objects, which is the purpose of GetCart and SaveCart methods.

The middleware we registered in the Startup class in task 38 uses cookies or URL rewriting to associate multiple requests from a user together to form a single browsing session. A related feature is session state, which associates data with a session.

Model Binding - in the CartController.cs class the action methods AddToCart(int productId, stringreturnUrl) and RemoveFromCart(int productId, string returnUrl) have parameter names that match the input elemnts in the HTML form on the ProductSummary.cshtml partial view. This allows MVC to associate incoming form POST variables with those parameters, eliminating the need to process the form.

$Defining Session State Extension Methods
ASP.NET Core's session state feature only stores int, string, and byte[] values so we have to serialize the Cart objectss into JSON. We do this by defining extension methods to the ISession interface in a new class we create in the Infrastructure folder called SessionExtensions.cs.

Extension methods are static methods defined in a static class such as this:
namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this string str)
        {
            return str.Split(new char[] { ' ', '.', '?' },
                             StringSplitOptions.RemoveEmptyEntries).Length;
        }
    }
}
This allows us to call the WordCount method like an instance method on "string" data types such as this:
string s = "Hello Extension Methods";
int i = s.WordCount();

40. Displaying the Contents of the Cart
We created a new view model (CartIndexViewModel.cs) to pass two pieces of data to the view returned in our Index action method:
	1) The Cart object
	2) The URL that will display if the user clicks the Continue Shopping button
The Index method passes this view model into the new view we created Index.cshtml in the Views/Cart folder.

41. Creating a Storage-Aware Cart Class
We want to replace how the persistence of the Cart class is handled, right now it is handled by the Cart controller. The problem with this is we will have to duplicate this code that obtains and stores Cart objects in any component that uses them. To refine this we will use the services feature to handle Cart objects.

We created the SessionCart.cs class which knows how to store itself in session data.

We made two new contributions to the services collection in the Startup class and made use of the Cart service in the CartController class so the CartController isn't doing work maintaing session data.

42. Removing Items from the Cart
We just added a form with two inputs one matching the ProductID and one matching the returnUrl parameters in the RemoveFromCart action method in the CartController class. The form also had a button "Remove" that submits the POST request specified by the form. This was done in the Index.cshtml view for the CartController.

43. Adding the Cart Summary Widget
Our goal here is to add a widget for users to view their cart whenever without having to add an item first. This is done the same way we implemented the category navigation menu, with view components.
We want to use an icon for the checkout option so we implement the Font Awesome package, an open source library of font symbols.
We add this package to the libman.json file since this should be something the client will see on their machine, we use the GUI in VS to import the package this time in Add -> Client-Side Libary on the project.
We created a new view component (CartSummaryViewComponent) which uses the Cart service we created and passes the Cart object to the Default.cshtml partial view in the Views/Shared/Components/CartSummary folder.

44. Creating the Order.cs Model Class
We now want to add a checkout and complete feature. We provide the support for gathering shipping details and add the application support to process those details. We add a model class (Order.cs) to hold all thiss shipping info.

45. Adding the Checkout Process
We added a new button to the Cart Index.cshtml view that makes a request for the Checkout action method on the new OrderController.cs controller class we made. This Checkout action method passes a new Order.cs model object to the view and returns a view called Checkout.cshtml to the user.

The asp-for attribute on the input elements generates the type, id, name, and value attributes based on the specified model property.

46. Implementing Order Processing
We added an Orders property to the ApplicationDbContext.cs file in the models folder and ran EF commands in the Package Manager Console, Add-Migration Orders, which creates a new migration called Orders. Then we updated the database schema for the application with the Update-Database command.

$Creating the Order Repository
We use the same pattern that we used to implement the product repository by creating an interface called IOrderRepository to the Models folder. Then we created an implementation of this interface by creating the EFOrderRepository.cs class. We tell MVC to use an instance of this class whenever it needs an implementation of the IOrderRepository.

47. Completing the Order Controller
To complete the OrderController.cs class we added a constructor that receives the services needed to process an order, the Cart service and the Order repository service. Then we create a new action method that will handle the HTTP form POST request when a user clicks "Complete Order"

We created another Checkout action method decorated with the [HttpPost] attribute tag, this indicates the action method only gets invoked whenever a POST request is sent (when the user submits the form, "Complete Order" button).

We also added a div element with the asp-validation-summary tag helper to the top of the Checkout.cshtml view to display any Model Validation errors to the user.

50. Managing Orders
We are adding a simple admin tool that will allow the admin to mark orders as shipped. We add a property to the Order.cs class called Shipped to track this information. This requires us to update the current version of the database as we are adding to a Model class that essentially represents a table in our database.

51. Adding the Actions and View
We added two actions to the OrderController to handle logic for Orders that have or have not been shipped. The List action method returns a View that includes a list of orders that have not been shipped and the MarkShipped action method in invoked on POST requests that specify the orderID and marks it as shipped in the database.

52. Adding Catalog Management
The convention for managing more complex collections of items is to present the user with two types of pages: a list page and an edit page.
We want our catalog management to be like a CRUD UI where we can create, read, update, and delete items in the collection.
We add a separate controller (AdminController.cs) to manage our product catalog. This controller has an Index action method that calls the View method and passing the list of products in the database to the view. We created the Index.cshtml view in the View/Admin folder now we can see a list of all the products and we have buttons that map to future action methods Edit, Create, and Delete.

53. Editing Products
We want to display a page that will allow admins to change values for the properties of a product and add an action method that can process those changes when they are submitted. This will be an Edit action method decorated with a [HttpPost] attribute tag. We created the Edit.cshtml view which displays an edit screen for a given productId. This id is determined by what row of the Index.cshtml screen the user selects the Edit button from.

54. Updating the Product Repository
We added a SaveProduct method to the IProductRepository interface and subsequently to the EFProductRepository class as well since this class implements the interface. We added logic in this method to save the parameter Product object to the database if there is no product that exists already for it and updates the existing product if it already exists in the database.

55. Handling Edit POST Requests
We added a POST Edit action method that handles saving the edited product to the repository and displaying a successful message to the user. We display the message using TempData, a key:value dictionary we can define properties for that gets deleted once we read from the dictionary. This is so we don't see old success messages when we update other records. We displayed this message on the shared _AdminLayout.cshtml view so that all views that use this layout can show the success message.

56. Adding Model Validation for Product Model
We decorated the Product Model properties with attribute tags like [Required(ErrorMessage = "Please enter a name")]
so we can display these error messages to the user on each form element that violates the model validations.

57. Enabling Client-Side Validation
Currently data validation is applied when the admin submits data to the server, but we want to validate the data before sending it off to the server. To do this we add JavaScript libraries to the libman.json file to allow us to validate on the client-side (jquery-validate and jquery validation-unobstrusive). We added a few script tags to the _AdminLayout.cshtml view to load these libraries once the administration features are used (i.e. loading a view that inherits from the _AdminLayout.cshtml view).

IMPORTANT: It is good to validate data entered by users at client-side, but do not authenticate in client-side, authentication should be done at server-side. Authentication on the client-side would involve sending valid credentials from the server to client to perform authentication against the username and password that the client entered.